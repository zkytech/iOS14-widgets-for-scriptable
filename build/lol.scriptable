{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "light-gray",
    "glyph" : "magic"
  },
  "name" : "LOL",
  "script" : "\/\/ Variables used by Scriptable.\n\/\/ These must be at the very top of the file. Do not edit.\n\/\/ icon-color: orange; icon-glyph: magic;\n\n\/\/ LOL近期赛事列表小组件\n\/\/ 支持中号、大号组件.\n\/\/ 如果组件崩溃或出现任何问题，请尝试重新下载 Release：https:\/\/github.com\/zkytech\/iOS14-widgets-for-scriptable\/releases\n\/\/ 如果仍无法解决，请反馈至：https:\/\/github.com\/zkytech\/iOS14-widgets-for-scriptable\/issues\ntry {\n  const mainW = new ListWidget();\n  presentSize = \"large\";\n  mainW.backgroundColor = new Color(\"#282E4D\");\n  const LW = mainW.addStack();\n  LW.layoutVertically();\n  LW.centerAlignContent();\n  let lineHeight = 30; \/\/ 图片的高度\n  let teamNameFontSize = lineHeight * 0.5; \/\/ 队名文本大小\n  let teamTxtWidth = 60; \/\/ 队名的容器宽度\n  let timeStrWidth = 60; \/\/ 比赛开始时间的容器宽度，比如：\"16:00\"\n  let lineWidth = teamTxtWidth * 2 + lineHeight * 3 + timeStrWidth;\n  let dateStrWidth = 60; \/\/ 分割线中的日期的宽度\n  let dlineWidth = (lineWidth - dateStrWidth) \/ 2; \/\/ 分割线的左右两侧宽度比如 : ------2020-10-05------\n  if (config.runsInWidget) {\n    presentSize = null;\n  }\n  \/**\n   * 加载未进行的赛事的数据\n   *\/\n  async function loadLolUpcomingMatches() {\n    const req = new Request(\n      \"https:\/\/widget.zkytech.top\/widget\/lol\/getUpcomingMatches\"\n    );\n    return req.loadJSON().then((res) => res.data);\n  }\n\n  \/**\n   * 加载正在进行的赛事的数据\n   *\/\n  async function loadLolRunningMatches() {\n    const req = new Request(\n      \"https:\/\/widget.zkytech.top\/widget\/lol\/getRunningMatches\"\n    );\n    return req.loadJSON().then((res) => res.data);\n  }\n\n  \/**\n   * 加载未进行的赛事的数据\n   *\/\n  async function loadLolPastMatches() {\n    const req = new Request(\n      \"https:\/\/widget.zkytech.top\/widget\/lol\/getPastMatches\"\n    );\n    return req.loadJSON().then((res) => res.data);\n  }\n\n  let pastMatches = await loadLolPastMatches();\n  let runningMatches = await loadLolRunningMatches();\n  let upcomingMatches = await loadLolUpcomingMatches();\n  \/**\n   * 渲染大号组件\n   *\/\n  async function renderLarge() {\n    let matches = pastMatches.concat(runningMatches).concat(upcomingMatches);\n    if (matches.length > 6) {\n      matches = matches.slice(matches.length - 7, matches.length - 2);\n    }\n    if (matches.length === 6) {\n      matches = matches.slice(0, 5);\n    }\n\n    const matchImg = await loadImage(\n      matches[matches.length - 1].league.image_url\n    ); \/\/ 赛事logo\n    const matchImageStack = LW.addStack();\n    matchImageStack.size = new Size(267, 50);\n    const matchImage = matchImageStack.addImage(matchImg);\n\n    matchImage.imageSize = new Size(50, 50);\n    await renderMatchList(matches);\n  }\n\n  \/**\n   * 渲染中号组件\n   *\/\n  async function renderMedium() {\n    let matches = runningMatches.concat(upcomingMatches).slice(0, 2);\n    const lt = 2 - matches.length;\n    matches = pastMatches\n      .slice(pastMatches.length - lt, pastMatches.length)\n      .concat(matches);\n    await renderMatchList(matches);\n  }\n\n  \/**\n   * 渲染小号组件\n   *\/\n  async function renderSmall() {\n    const container = LW;\n    container.layoutVertically();\n    let matches = runningMatches.concat(upcomingMatches).slice(0, 6);\n    const lt = 6 - matches.length;\n    matches = pastMatches\n      .slice(pastMatches.length - lt, pastMatches.length)\n      .concat(matches);\n\n    let lastDate = new Date(pastMatches[0].scheduled_at).getDate();\n\n    for (let i = 0; i < matches.length; i++) {\n      const val = matches[i];\n      const team1 = val.opponents[0].opponent; \/\/ 队伍1\n      const team2 = val.opponents[1].opponent; \/\/ 队伍2\n      const matchScheduledAt = new Date(val.scheduled_at); \/\/ 比赛开始时间\n      const timeStr = dateFormat(\"HH:MM\", matchScheduledAt);\n\n      if (i === 0 || matchScheduledAt.getDate() !== lastDate) {\n        addDivider(\n          matchScheduledAt,\n          (lineWidth \/ 2) * 1.2,\n          12,\n          dlineWidth \/ 2,\n          dateStrWidth\n        ); \/\/ 日期分割线\n      }\n      lastDate = matchScheduledAt.getDate();\n\n      const line = container.addStack();\n      container.addSpacer(3);\n\n      line.layoutHorizontally();\n      const timeStack = line.addStack();\n      const leftTeamStack = line.addStack();\n      const scoreStack = line.addStack();\n      const rightTeamStack = line.addStack();\n\n      timeStack.size = new Size(16 * 3, 16);\n      leftTeamStack.size = new Size(16 * 2.5, 16);\n      scoreStack.size = new Size(16 * 2, 16);\n      rightTeamStack.size = new Size(16 * 2.5, 16);\n\n      scoreStack.layoutHorizontally();\n      const timeTxt = timeStack.addText(timeStr);\n      const leftTeamTxt = leftTeamStack.addText(team1.acronym);\n      const rightTeamTxt = rightTeamStack.addText(team2.acronym);\n\n      let [leftScoreTxt, dividerTxt, rightScoreTxt, vsTxt] = [\n        null,\n        null,\n        null,\n        null,\n        null,\n      ];\n      if (val.status === \"finished\" || val.status === \"running\") {\n        if (team1.id === val.results[0].team_id) {\n          team1.score = val.results[0].score;\n          team2.score = val.results[1].score;\n        } else {\n          team1.score = val.results[1].score;\n          team2.score = val.results[0].score;\n        }\n\n        const leftScore = scoreStack.addStack();\n        const dividerStack = scoreStack.addStack();\n        const rightScore = scoreStack.addStack();\n        leftScoreTxt = leftScore.addText(team1.score.toString());\n        dividerTxt = dividerStack.addText(\":\");\n        rightScoreTxt = rightScore.addText(team2.score.toString());\n      } else {\n        vsTxt = scoreStack.addText(\"VS\");\n      }\n      const txts = [\n        timeTxt,\n        leftTeamTxt,\n        rightTeamTxt,\n        leftScoreTxt,\n        dividerTxt,\n        rightScoreTxt,\n        vsTxt,\n      ];\n      txts.forEach((t) => {\n        if (t) {\n          t.font = Font.thinMonospacedSystemFont(15);\n          t.textColor = Color.white();\n        }\n      });\n    }\n  }\n\n  async function renderMatchList(matches) {\n    let lastDate = new Date(pastMatches[0].scheduled_at).getDate();\n    for (let i = 0; i < matches.length; i++) {\n      const val = matches[i];\n\n      const team1 = val.opponents[0].opponent; \/\/ 队伍1\n      const team2 = val.opponents[1].opponent; \/\/ 队伍2\n      const matchScheduledAt = new Date(val.scheduled_at); \/\/ 比赛开始时间\n      const timeStr = dateFormat(\"HH:MM\", matchScheduledAt);\n      if (i === 0 || matchScheduledAt.getDate() !== lastDate) {\n        addDivider(matchScheduledAt, lineWidth, 12, dlineWidth, dateStrWidth); \/\/ 日期分割线\n      }\n      lastDate = matchScheduledAt.getDate();\n      \/\/ 队伍logo\n      const team1Logo = await loadImage(team1.image_url);\n      const team2Logo = await loadImage(team2.image_url);\n      team1Logo.size = new Size(lineHeight, lineHeight);\n      team2Logo.size = new Size(lineHeight, lineHeight);\n      if (team1.id === val.results[0].team_id) {\n        team1.score = val.results[0].score;\n        team2.score = val.results[1].score;\n      } else {\n        team1.score = val.results[1].score;\n        team2.score = val.results[0].score;\n      }\n      const LWl = LW.addStack();\n      LWl.size = new Size(lineWidth, lineHeight + teamNameFontSize);\n      const container = LWl.addStack(); \/\/ 多套一层是为了居中\n      container.url = val.live_url;\n      LW.addSpacer(6);\n      const timeStrStack = container.addStack();\n      const timeStrTxt = timeStrStack.addText(timeStr);\n      timeStrStack.size = new Size(60, lineHeight + teamNameFontSize);\n      timeStrStack.layoutVertically();\n      timeStrStack.centerAlignContent();\n      timeStrTxt.font = Font.thinMonospacedSystemFont(lineHeight * 0.7);\n      timeStrTxt.textColor = Color.white();\n      const team1Stack = container.addStack(); \/\/ 队伍1的logo、队名\n      const scoreStack = container.addStack(); \/\/ 比分、比赛状态信息\n      const team2Stack = container.addStack(); \/\/ 队伍2的logo、队名\n\n      team1Stack.layoutVertically();\n      team2Stack.layoutVertically();\n      scoreStack.layoutVertically();\n      const scoreStack1 = scoreStack.addStack(); \/\/ 比分\n      const scoreStack2 = scoreStack.addStack(); \/\/ 比赛状态 (已结束\/进行中\/未开始)\n\n      scoreStack1.size = new Size(lineHeight * 3, lineHeight);\n      if (val.status === \"not_started\") {\n        const vsTxt = scoreStack1.addText(\"VS\");\n        vsTxt.font = Font.boldMonospacedSystemFont(lineHeight);\n        vsTxt.textColor = Color.white();\n      } else {\n        const team1ScoreStack = scoreStack1.addStack(); \/\/ 队伍1的分数\n        const scoreDividerStack = scoreStack1.addStack(); \/\/ 冒号\n        const team2ScoreStack = scoreStack1.addStack(); \/\/ 队伍2的分数\n\n        const scoreDividerTxt = scoreDividerStack.addText(\":\");\n        team1ScoreStack.layoutHorizontally();\n        team2ScoreStack.layoutHorizontally();\n        scoreDividerStack.layoutHorizontally();\n        team1ScoreStack.centerAlignContent();\n        team2ScoreStack.centerAlignContent();\n        scoreDividerStack.centerAlignContent();\n        const team1ScoreTxt = team1ScoreStack.addText(team1.score.toString());\n        const team2ScoreTxt = team2ScoreStack.addText(team2.score.toString());\n        team1ScoreStack.size = new Size(lineHeight * 0.65, lineHeight);\n        team2ScoreStack.size = new Size(lineHeight * 0.65, lineHeight);\n        scoreDividerStack.size = new Size(lineHeight * 0.65, lineHeight);\n\n        const widgetTxts = [scoreDividerTxt, team1ScoreTxt, team2ScoreTxt];\n        widgetTxts.forEach((txt) => {\n          txt.centerAlignText();\n          txt.font = Font.boldMonospacedSystemFont(lineHeight);\n          txt.textColor = Color.white();\n        });\n\n        if (team1.score > team2.score) {\n          team2ScoreTxt.textColor = Color.darkGray();\n        } else if (team1.score < team2.score) {\n          team1ScoreTxt.textColor = Color.darkGray();\n        }\n        scoreDividerTxt.textColor = Color.darkGray();\n      }\n      scoreStack1.layoutHorizontally();\n      scoreStack1.centerAlignContent();\n      let status = val.status;\n      \/\/ 当前状态\n      if (status === \"finished\") {\n        status = \"已结束\";\n      } else if (status === \"running\") {\n        status = \"进行中\";\n      } else if (status === \"not_started\") {\n        status = \"未开始\";\n      }\n      let statusTxt = scoreStack2.addText(status);\n      scoreStack2.size = new Size(lineHeight * 3, lineHeight);\n\n      scoreStack1.layoutHorizontally();\n      scoreStack1.centerAlignContent();\n\n      const team1ImgStack = team1Stack.addStack();\n      const team1TxtStack = team1Stack.addStack();\n\n      const team2ImgStack = team2Stack.addStack();\n      const team2TxtStack = team2Stack.addStack();\n      const team1Img_ = team1ImgStack.addImage(team1Logo);\n      const team2Img_ = team2ImgStack.addImage(team2Logo);\n\n      const team1Txt = team1TxtStack.addText(val.opponents[0].opponent.acronym);\n      const team2Txt = team2TxtStack.addText(val.opponents[1].opponent.acronym);\n      team1ImgStack.size = new Size(teamTxtWidth, lineHeight);\n      team2ImgStack.size = new Size(teamTxtWidth, lineHeight);\n      team1Img_.imageSize = new Size(lineHeight, lineHeight);\n      team2Img_.imageSize = new Size(lineHeight, lineHeight);\n      team1TxtStack.size = new Size(teamTxtWidth, teamNameFontSize);\n      team2TxtStack.size = new Size(teamTxtWidth, teamNameFontSize);\n\n      const widgetTxts = [team1Txt, team2Txt, statusTxt];\n      widgetTxts.forEach((txt) => {\n        txt.centerAlignText();\n        txt.font = Font.thinMonospacedSystemFont(lineHeight);\n        txt.textColor = Color.white();\n      });\n      team1Txt.font = Font.thinMonospacedSystemFont(teamNameFontSize);\n      team2Txt.font = Font.thinMonospacedSystemFont(teamNameFontSize);\n      statusTxt.font = Font.thinMonospacedSystemFont(teamNameFontSize - 1);\n      if (val.status === \"running\") {\n        statusTxt.textColor = Color.green();\n      }\n      if (val.status === \"finished\") {\n        statusTxt.textColor = Color.darkGray();\n      }\n    }\n  }\n\n  \/**\n   * 图片缓存到本地\n   * @param {string} imageUrl : 图片URL\n   *\/\n  async function loadImage(imageUrl) {\n    const fm = FileManager.local();\n    const path = fm.documentsDirectory() + imageUrl.split(\"\/\/\")[1];\n\n    const temp = imageUrl.split(\"\/\");\n    const filename = temp[temp.length - 1];\n    fm.createDirectory(path.split(filename)[0], true);\n    if (!fm.fileExists(path)) {\n      const img = await new Request(imageUrl).loadImage();\n      fm.writeImage(path, img);\n      return img;\n    } else {\n      return fm.readImage(path);\n    }\n  }\n\n  \/**\n   * 获取日期（周一、周二、周三....）\n   * @param {Date} date :\n   *\/\n  function getDay(date) {\n    const dayMap = {\n      0: \"周日\",\n      1: \"周一\",\n      2: \"周二\",\n      3: \"周三\",\n      4: \"周四\",\n      5: \"周五\",\n      6: \"周六\",\n    };\n    return dayMap[date.getDay()];\n  }\n\n  \/**\n   * 时间格式化\n   * @param {string} fmt :模板字符串 : \"YYYY-mm-dd HH:MM\"\n   * @param {Date} date :Date对象\n   *\/\n  function dateFormat(fmt, date) {\n    let ret;\n    const opt = {\n      \"Y+\": date.getFullYear().toString(), \/\/ 年\n      \"m+\": (date.getMonth() + 1).toString(), \/\/ 月\n      \"d+\": date.getDate().toString(), \/\/ 日\n      \"H+\": date.getHours().toString(), \/\/ 时\n      \"M+\": date.getMinutes().toString(), \/\/ 分\n      \"S+\": date.getSeconds().toString(), \/\/ 秒\n      \/\/ 有其他格式化字符需求可以继续添加，必须转化成字符串\n    };\n    for (let k in opt) {\n      ret = new RegExp(\"(\" + k + \")\").exec(fmt);\n      if (ret) {\n        fmt = fmt.replace(\n          ret[1],\n          ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, \"0\")\n        );\n      }\n    }\n    return fmt;\n  }\n\n  \/**\n   * 渲染日期分割线左右侧的线条\n   * @param {*} dividerStack : 分割线容器\n   * @param {*} dividerLineWidth : 分割线宽度\n   * @param {*} dividerLineHeight : 分割线高度\n   *\/\n  function addDividerLine(dividerStack, dividerLineWidth, dividerLineHeight) {\n    const sideDividerStack = dividerStack.addStack();\n    sideDividerStack.size = new Size(dividerLineWidth, dividerLineHeight);\n    sideDividerStack.layoutVertically();\n    sideDividerStack.addStack().size = new Size(\n      dividerLineWidth,\n      Math.floor(dividerLineHeight \/ 2) - 1\n    );\n    const sideDivider = sideDividerStack.addStack();\n    sideDivider.size = new Size(dividerLineWidth, 1);\n    sideDivider.backgroundColor = Color.white();\n  }\n\n  \/**\n   * 渲染日期分割线\n   * @param {Date} date : 日期对象\n   * @param {number} dividerWidth : 分割线宽度\n   * @param {number} dividerHeight : 分割线高度\n   * @param {number} dividerLineWidth : 分割线左右侧线条的宽度\n   * @param {number} dividerTxtWidth : 分割线中的日期文本的宽度\n   *\/\n  function addDivider(\n    date,\n    dividerWidth,\n    dividerHeight,\n    dividerLineWidth,\n    dividerTxtWidth\n  ) {\n    const day = getDay(date);\n    const dividerStack = LW.addStack();\n    \/\/ 渲染左侧分割线\n    addDividerLine(dividerStack, dividerLineWidth, dividerHeight);\n    \/\/ 日期文本容器\n    const dividerTxtStack = dividerStack.addStack();\n    \/\/ 渲染右侧分割线\n    addDividerLine(dividerStack, dividerLineWidth, dividerHeight);\n    \/\/ 渲染日期文本\n    dividerStack.size = new Size(dividerWidth, dividerHeight);\n    dividerTxtStack.size = new Size(dividerTxtWidth, dividerHeight);\n    const dividerTxt = dividerTxtStack.addText(day);\n    dividerTxt.font = Font.thinMonospacedSystemFont(dividerHeight - 1);\n    dividerTxt.textColor = Color.white();\n  }\n\n  if (config.widgetFamily === \"large\" || presentSize === \"large\") {\n    await renderLarge();\n  }\n\n  if (config.widgetFamily === \"medium\" || presentSize === \"medium\") {\n    await renderMedium();\n  }\n\n  if (config.widgetFamily === \"small\" || presentSize === \"small\") {\n    await renderSmall();\n  }\n\n  if (!config.runsInWidget) {\n    if (presentSize == \"large\") {\n      await mainW.presentLarge();\n    }\n\n    if (presentSize == \"medium\") {\n      await mainW.presentMedium();\n    }\n\n    if (presentSize == \"small\") {\n      await mainW.presentSmall();\n    }\n  }\n\n  Script.setWidget(mainW);\n\n  Script.complete();\n\n  \/**\n   * 自动更新\n   *\/\n  async function update() {\n    const fm = FileManager.iCloud();\n    const folder = fm.documentsDirectory();\n    const req = new Request(\n      \"https:\/\/widget.deepal.fun\/iOS14-widgets-for-scriptable\/lol.js\"\n    );\n    let scriptTxt = await req.loadString();\n\n    if (!scriptTxt.includes(\"setWidget\")) {\n      return;\n    }\n\n    const filename = `\/${Script.name()}.js`;\n    if(req.response.statusCode == 200){\n      fm.writeString(folder + filename, scriptTxt);\n    }\n  }\n\n  \/\/ await update()\n} catch {\n  console.log(e);\n}\n",
  "share_sheet_inputs" : [

  ]
}