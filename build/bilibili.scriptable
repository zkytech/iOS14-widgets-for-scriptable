{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "brown",
    "glyph" : "magic"
  },
  "name" : "bilibili",
  "script" : "\/\/ Variables used by Scriptable.\n\/\/ These must be at the very top of the file. Do not edit.\n\/\/ icon-color: pink; icon-glyph: video;\n\/\/ iOS 14 widget --- bilibili最近更新番剧信息\n\/\/ 支持大、中、小 组件\n\/\/ 可通过传入参数( all\/global\/cn )来控制显示 全部番剧、国外番剧、国内番剧\n\/\/ 如果组件崩溃或出现任何问题，请尝试重新下载 Release：https:\/\/github.com\/zkytech\/iOS14-widgets-for-scriptable\/releases\n\/\/ 如果仍无法解决，请反馈至：https:\/\/github.com\/zkytech\/iOS14-widgets-for-scriptable\/issues\ntry {\n  const LW = new ListWidget(); \/\/ widget对象\n  LW.url = \"bilibili:\/\/\"; \/\/ 点击小组件跳转到bilibili\n  let presentSize = \"large\"; \/\/ 预览组件的大小,可设置为 large\/medium\/small\n  const mainColor = new Color(\"#FB7299\");\n\n  let userDefineTarget = \"global\"; \/\/ 用户界面传入widget的参数：全部\/国外\/国内\/all\/global\/cn\n  let followLimited = false; \/\/ 是否仅显示追番\n  const followType = 1; \/\/ 1 、2 对应 追番、追剧，目前追剧相关功能暂未实现.所以这里设为固定值1。该功能要求用户在B站APP - 我的 - 点击头像 - 点击 右上角菜单 - 空间设置 - 打开“公开显示订阅”开关\n  let uid = 8165988; \/\/ 用户的UID，配合追番功能使用\n  let params = [userDefineTarget, followLimited, uid];\n\n  if (config.runsInWidget) {\n    presentSize = null;\n    params = args.widgetParameter ? args.widgetParameter.split(\",\") : [];\n  }\n\n  let awp = params[0];\n  const awpMap = {\n    国产: \"cn\",\n    国创: \"cn\",\n    番剧: \"global\",\n    进口: \"global\",\n    全部: \"all\",\n  };\n\n  awp = awpMap[awp] ? awpMap[awp] : awp;\n  if (awp === \"global\" || awp === \"cn\" || awp === \"all\") {\n    userDefineTarget = awp;\n  }\n\n  let flp = params[1] ? params[1] : false;\n\n  const flpMap = {\n    追番: true,\n    全部: false,\n    true: true,\n    false: false,\n  };\n  flp = flpMap[flp] ? flpMap[flp] : flp;\n\n  if (flp === true || flp === false) {\n    followLimited = flp;\n  }\n\n  uid = params[2];\n\n  if (\n    (uid === undefined || uid === null) &&\n    params.length != 1 &&\n    followLimited == true\n  ) {\n    throw new Error(\n      \"请在参数中填写uid\\n\\t参数填写范例：全部,追番,8165988\\n\\t其中逗号全部为英文逗号\\n\\n uid获取方式：B站APP - 我的 - 点击头像 - 详情\"\n    );\n  }\n  \/**\n   * 加载番剧timeline\n   * @param {string} range: 可选值 global、cn 分别代表 进口、国产\n   *\/\n  async function loadItems(range) {\n    let follows = [];\n    if (followLimited) {\n      \/\/ 仅显示追番\n      \/\/ 获取追番列表\n      follows = await loadFollow(followType);\n    }\n    return new Request(`https:\/\/bangumi.bilibili.com\/web_api\/timeline_${range}`)\n      .loadJSON()\n      .then((res) => {\n        let allSeason = [];\n        res.result.forEach((val, i) => {\n          allSeason = allSeason.concat(val.seasons);\n        });\n        return allSeason;\n      })\n      .then((seasons) => {\n        \/\/ 过滤港澳台 和 本周停更\n        let result = seasons.filter(\n          (sea) =>\n            sea.title.indexOf(\"港澳台\") == -1 &&\n            sea.title.indexOf(\"僅限台灣地區\") == -1 &&\n            Number(sea.delay) === 0\n        );\n        if (followLimited) {\n          result = result.filter((sea) => follows.indexOf(sea.title) !== -1);\n        }\n        return result;\n      });\n  }\n\n  \/**\n   * 追番\/追剧列表\n   * @param {number} followType : 可选值 1 、2 分别代表 追番、追剧\n   *\/\n  function loadFollow(followType) {\n    \/\/ 出于性能以及实际情况考虑，仅处理前30条追番\n    return new Request(\n      `https:\/\/api.bilibili.com\/x\/space\/bangumi\/follow\/list?type=${followType}&ps=30&vmid=${uid}`\n    )\n      .loadJSON()\n      .then((res) => {\n        return res.data.list.map((fd) => fd.title);\n      });\n  }\n\n  \/**\n   * 加载season中的square_cover图片并保存至season.img\n   * @param {Season} sea : 番剧信息\n   *\/\n  async function loadImg(sea) {\n    \/\/加载图片\n    let req1 = new Request(sea.square_cover);\n    let img = await req1.loadImage();\n    sea.img = img;\n    return sea;\n  }\n\n  const dayMap = {\n    0: \"周日\",\n    1: \"周一\",\n    2: \"周二\",\n    3: \"周三\",\n    4: \"周四\",\n    5: \"周五\",\n    6: \"周六\",\n  };\n\n  \/**\n   * 获取番剧的更新日期（周一、周二、周三....）\n   * @param {Season} sea : 番剧信息\n   *\/\n  function getDay(sea) {\n    return dayMap[new Date(sea.pub_ts * 1000).getDay()];\n  }\n\n  const globalSeasons = await loadItems(\"global\");\n  const cnSeasons = await loadItems(\"cn\");\n  let seasons = [];\n\n  if (userDefineTarget === \"all\") {\n    seasons = globalSeasons.concat(cnSeasons);\n    seasons.sort((s1, s2) => Number(s1.pub_ts) - Number(s2.pub_ts));\n  } else if (userDefineTarget === \"global\") {\n    seasons = globalSeasons;\n  } else if (userDefineTarget === \"cn\") {\n    seasons = cnSeasons;\n  }\n\n  \/**\n   * 渲染日期分割线左右侧的线条\n   * @param {*} dividerStack : 分割线容器\n   * @param {*} dividerLineWidth : 分割线宽度\n   * @param {*} dividerLineHeight : 分割线高度\n   *\/\n  function addDividerLine(dividerStack, dividerLineWidth, dividerLineHeight) {\n    const sideDividerStack = dividerStack.addStack();\n    sideDividerStack.size = new Size(dividerLineWidth, dividerLineHeight);\n    sideDividerStack.layoutVertically();\n    sideDividerStack.addStack().size = new Size(\n      dividerLineWidth,\n      Math.floor(dividerLineHeight \/ 2) - 1\n    );\n    const sideDivider = sideDividerStack.addStack();\n    sideDivider.size = new Size(dividerLineWidth, 1);\n    sideDivider.backgroundColor = Color.white();\n  }\n\n  \/**\n   * 渲染日期分割线\n   * @param {string} day : 日期文本\n   * @param {number} dividerWidth : 分割线宽度\n   * @param {number} dividerHeight : 分割线高度\n   * @param {number} dividerLineWidth : 分割线左右侧线条的宽度\n   * @param {number} dividerTxtWidth : 分割线中的日期文本的宽度\n   *\/\n  function addDivider(\n    day,\n    dividerWidth,\n    dividerHeight,\n    dividerLineWidth,\n    dividerTxtWidth\n  ) {\n    const dividerStack = LW.addStack();\n    \/\/ 渲染左侧分割线\n    addDividerLine(dividerStack, dividerLineWidth, dividerHeight);\n    \/\/ 日期文本容器\n    const dividerTxtStack = dividerStack.addStack();\n    \/\/ 渲染右侧分割线\n    addDividerLine(dividerStack, dividerLineWidth, dividerHeight);\n    \/\/ 渲染日期文本\n    dividerStack.size = new Size(dividerWidth, dividerHeight);\n    dividerTxtStack.size = new Size(dividerTxtWidth, dividerHeight);\n    const dividerTxt = dividerTxtStack.addText(day);\n    dividerTxt.font = Font.thinMonospacedSystemFont(dividerHeight);\n    dividerTxt.textColor = Color.white();\n  }\n\n  \/**\n   * 渲染番剧列表\n   *\/\n  async function renderList() {\n    const stackHeight = 35; \/\/ 每条番剧信息的高度\n    const timeTxtWidth = 50; \/\/ 时间字符串的宽度\n    const imgWidth = stackHeight; \/\/ 图片的宽度\n    const itemSpacer = 5;\n    const contentTxtWidth = 250; \/\/ 番剧名称的宽度\n    const dividerWidth =\n      timeTxtWidth + imgWidth + contentTxtWidth + itemSpacer * 2; \/\/ 分割线的宽度\n    const dividerTxtWidth = 40; \/\/ 分割线中的文本的宽度\n    const dividerLineWidth = (dividerWidth - dividerTxtWidth) \/ 2; \/\/左右两侧分割线的宽度\n    const dividerHeight = 12; \/\/ 分割线的高度\n    \/\/ 加载预览图\n    for (i = 0; i < seasons.length; i++) {\n      await loadImg(seasons[i]);\n    }\n    let lastDay = getDay(seasons[0]); \/\/ 上一个番剧的更新日期\n    addDivider(\n      lastDay,\n      dividerWidth,\n      dividerHeight,\n      dividerLineWidth,\n      dividerTxtWidth\n    );\n    \/\/ 遍历番剧信息并渲染到列表\n    seasons.forEach((sea) => {\n      const nowDay = getDay(sea); \/\/ 当前番剧的更新日期\n      \/\/ 日期发生变化，添加日期分割线\n      if (nowDay !== lastDay) {\n        addDivider(\n          nowDay,\n          dividerWidth,\n          dividerHeight,\n          dividerLineWidth,\n          dividerTxtWidth\n        );\n        lastDay = nowDay;\n      }\n      const stack = LW.addStack();\n      stack.spacing = itemSpacer;\n      \/\/ 该url会调起bilibili app到相应的番剧页面\n      stack.url = `bilibili:\/\/bangumi\/season\/${sea.season_id}`;\n      stack.layoutHorizontally();\n      const timeTxtStack = stack.addStack(); \/\/ 时间文本容器\n      timeTxtStack.centerAlignContent();\n      const timeTxt = timeTxtStack.addText(sea.pub_time); \/\/ 时间文本\n      timeTxtStack.size = new Size(timeTxtWidth, stackHeight);\n\n      const imgStack = stack.addStack(); \/\/ 图片容器\n\n      imgStack.size = new Size(imgWidth, stackHeight);\n      const stackImg = imgStack.addImage(sea.img); \/\/ 图片\n\n      stackImg.cornerRadius = 5;\n      stackImg.imageSize = new Size(stackHeight, stackHeight);\n\n      const contentTxtStack = stack.addStack(); \/\/ 番剧标题容器\n      contentTxtStack.layoutVertically();\n      contentTxtStack.centerAlignContent();\n      contentTxtStack.size = new Size(contentTxtWidth, stackHeight);\n      const contentTxt = contentTxtStack.addText(sea.title); \/\/ 番剧标题\n      const indexTxt = contentTxtStack.addText(sea.pub_index); \/\/ 第几话\n      contentTxt.font = Font.boldRoundedSystemFont(15);\n      contentTxt.textColor = Color.white();\n      indexTxt.font = Font.thinMonospacedSystemFont(10);\n      indexTxt.textColor = Color.white();\n      timeTxt.font = Font.thinMonospacedSystemFont(18);\n      timeTxt.textColor = Color.white();\n      if (Number(sea.is_published) == 0) {\n        \/\/ 番剧待更新，显示为灰色\n        contentTxt.textColor = Color.gray();\n        indexTxt.textColor = Color.gray();\n        timeTxt.textColor = Color.gray();\n      }\n      LW.addSpacer(1);\n    });\n  }\n\n  \/**\n   * 渲染最近的maxN条番剧信息，包含已更新和待更新番剧\n   * @param {number} maxN:最大可容纳番剧数目\n   *\/\n  async function renderCutList(maxN) {\n    let ti = 0;\n    seasons.forEach((sea, i) => {\n      if (sea.is_published) {\n        ti = i;\n      }\n    });\n    if (ti < seasons.length - 1) {\n      ti = ti + 1;\n    }\n    let ei = ti + Math.floor(maxN \/ 2); \/\/ 显示Math.floor(maxN\/2)条待更新番剧信息\n    let si = ei - maxN;\n    si = si >= 0 ? si : 0;\n    if (ei > seasons.length) {\n      ei = seasons.length;\n    }\n    seasons = seasons.slice(si, ei);\n    await renderList();\n  }\n\n  if (config.widgetFamily == \"large\" || presentSize == \"large\") {\n    const titleSize = 36;\n    \/\/ 大号插件\n\n    const titleTxt = LW.addText(\"最近更新\");\n    \/\/     titleStack.addSpacer(10)\n    let contentType = \"番剧\";\n    if (userDefineTarget == \"global\") {\n      contentType = \"番剧\";\n    } else if (userDefineTarget == \"cn\") {\n      contentType = \"国创\";\n    } else if (userDefineTarget == \"all\") {\n      contentType = \"全部\";\n    }\n\n    const subTxt = LW.addText(contentType);\n    subTxt.textColor = Color.white();\n    subTxt.font = Font.thinMonospacedSystemFont(titleSize \/ 3);\n    titleTxt.font = Font.boldRoundedSystemFont(titleSize);\n    titleTxt.textColor = Color.white();\n    LW.addSpacer(10);\n    await renderCutList(7);\n  } else if (config.widgetFamily == \"medium\" || presentSize == \"medium\") {\n    \/\/ 中号的插件\n    await renderCutList(3);\n  } else if (config.widgetFamily == \"small\" || presentSize == \"small\") {\n    \/\/ 小号的插件\n    let target = seasons[0];\n    seasons.forEach((sea) => {\n      if (Number(sea.is_published) == 1) {\n        target = sea;\n        return false;\n      } else {\n        return true;\n      }\n    });\n    \/\/ 该url会调起bilibili app到相应的番剧页面\n    LW.url = `bilibili:\/\/bangumi\/season\/${target.season_id}`;\n    await loadImg(target);\n    LW.backgroundImage = target.img;\n    const txt = LW.addText(target.title);\n    txt.textColor = mainColor;\n    const indexTxt = LW.addText(target.pub_index);\n    indexTxt.font = Font.boldRoundedSystemFont(10);\n    indexTxt.textColor = mainColor;\n    txt.font = Font.boldRoundedSystemFont(20);\n  }\n\n  LW.backgroundColor = mainColor;\n  \/\/ LW.backgroundGradient = gradient\n\n  if (!config.runsInWidget) {\n    if (presentSize == \"large\") {\n      await LW.presentLarge();\n    }\n    if (presentSize == \"medium\") {\n      await LW.presentMedium();\n    }\n    if (presentSize == \"small\") {\n      await LW.presentSmall();\n    }\n  }\n\n  Script.setWidget(LW);\n\n  Script.complete();\n\n  \/**\n   * 自动更新\n   *\/\n  async function update() {\n    const fm = FileManager.iCloud();\n    const folder = fm.documentsDirectory();\n    const req = new Request(\n      \"https:\/\/public.zkytech.top\/iOS14-widgets-for-scriptable\/bilibili.js\"\n    );\n    let scriptTxt = await req.loadString();\n    const filename = `\/${Script.name()}.js`;\n    if(req.response.statusCode == 200){\n      fm.writeString(folder + filename, scriptTxt);\n    }\n  }\n  await update();\n} catch (e) {\n  console.log(e);\n}\n",
  "share_sheet_inputs" : [

  ]
}